/*
 * CS 440 Project 2 — C TEMPLATE (pthreads)
 * Name(s):
 * Date:
 *
 * Goal: Implement 2.a / 2.b / 2.c so that EACH experiment creates/destroys
 * exactly N_TOTAL threads (including all parent/initial/child/grandchild threads).
 *
 * This file includes:
 *  - skeleton runners for 2.a, 2.b, 2.c (non-batched)
 *  - skeleton runners for batching fallback
 *
 * Students: Fill in TODO blocks. Keep printing sparse.
 *
 * Build (example):
 *   gcc -O2 -pthread project2_template.c -o project2
 *
 * Note: This template uses pthreads. If you use a different threading library,
 * document it in your report.
 */

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdatomic.h>

// ======= Fixed baseline (A, B, C must match) =======
#define N_TOTAL 5000

// ======= 2.b parameters (must total exactly 5000) =======
// TODO: verify math: parents + parents*childrenPerParent == 5000
#define B_PARENTS 50
#define B_CHILDREN_PER_PARENT 99

// ======= 2.c parameters (must total exactly 5000) =======
// TODO: verify math:
// initials + initials*childrenPerInitial + initials*childrenPerInitial*grandchildrenPerChild == 5000
#define C_INITIALS 20
#define C_CHILDREN_PER_INITIAL 3
#define C_GRANDCHILDREN_PER_CHILD 82

// ======= Batching knobs (reduce concurrency if needed) =======
#define A_BATCH_SIZE 25
#define B_CHILD_BATCH_SIZE 25
#define C_GRANDCHILD_BATCH_SIZE 25

// ======= Counters =======
static atomic_int created = 0;
static atomic_int destroyed = 0;

// ============================================================
// Timing helper
// ============================================================
// TODO: If clock_gettime is not available on your system, use an alternative.
static long long now_ns(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (long long)ts.tv_sec * 1000000000LL + (long long)ts.tv_nsec;
}

static void reset_counts(void) {
    atomic_store(&created, 0);
    atomic_store(&destroyed, 0);
}

static void print_summary(const char *label, long long start_ns, long long end_ns) {
    double elapsed_ms = (end_ns - start_ns) / 1e6;
    printf("%s elapsed: %.3f ms\n", label, elapsed_ms);
    printf("Threads created:   %d\n", atomic_load(&created));
    printf("Threads destroyed: %d\n", atomic_load(&destroyed));
}

// ============================================================
// TODO: optional sparse logging helper
// ============================================================
// static atomic_int print_ticker = 0;
// static const int PRINT_EVERY = 500;
// static void maybe_log(const char *msg) { ... }

// ============================================================
// Thread stubs (students must define what each thread does)
// ============================================================
static void *flat_worker(void *arg) {
    // TODO: minimal work
    // TODO: ensure destroyed increments when thread exits
    atomic_fetch_add(&destroyed, 1);
    return NULL;
}

// ============================================================
// 2.a — Flat (no batching)
// ============================================================
static void run2a_flat_no_batching(void) {
    printf("\n=== 2.a Flat (no batching) ===\n");
    long long start = now_ns();

    // TODO: allocate pthread_t array of size N_TOTAL
    // TODO: for i in 0..N_TOTAL-1:
    //   - atomic_fetch_add(&created, 1)
    //   - pthread_create(...)
    // TODO: join all threads (optionally reverse order)
    // TODO: free allocated memory

    long long end = now_ns();
    print_summary("2.a", start, end);

    // TODO: verify created == destroyed == N_TOTAL
}

// ============================================================
// 2.a — Flat (batched)
// ============================================================
static void run2a_flat_batched(int batch_size) {
    printf("\n=== 2.a Flat (BATCHED), batch_size=%d ===\n", batch_size);
    long long start = now_ns();

    // TODO: create threads in batches:
    // next_id = 1
    // while next_id <= N_TOTAL:
    //   - allocate pthread_t batch array (size up to batch_size)
    //   - create up to batch_size threads, start them
    //   - join that batch
    //   - free batch array
    // end while

    long long end = now_ns();
    print_summary("2.a(batched)", start, end);

    // TODO: verify created == destroyed == N_TOTAL
}

// ============================================================
// 2.b — Two-level hierarchy (parent -> children)
// ============================================================

typedef struct {
    int parent_id;
    // TODO: include any other fields needed
} parent_arg_t;

static void *parent_worker_no_batching(void *arg) {
    parent_arg_t *pa = (parent_arg_t *)arg;

    // TODO: parent creates B_CHILDREN_PER_PARENT children
    // TODO: for each child:
    //   - atomic_fetch_add(&created, 1)
    //   - pthread_create child
    // TODO: join all children
    // TODO: parent increments destroyed when finishing
    atomic_fetch_add(&destroyed, 1);

    // TODO: free pa if allocated on heap
    return NULL;
}

static void run2b_two_level_no_batching(void) {
    printf("\n=== 2.b Two-level (no batching) ===\n");
    long long start = now_ns();

    // TODO: allocate pthread_t parent array size B_PARENTS
    // TODO: for parentId in 1..B_PARENTS:
    //   - atomic_fetch_add(&created, 1) // parent
    //   - allocate/prepare parent_arg_t (heap or static)
    //   - pthread_create parent thread
    // TODO: join all parents
    // TODO: free allocated memory

    long long end = now_ns();
    print_summary("2.b", start, end);

    // TODO: verify created == destroyed == N_TOTAL
}

// ============================================================
// 2.b — Two-level hierarchy (batched children, if needed)
// ============================================================

typedef struct {
    int parent_id;
    int child_batch_size;
} parent_batch_arg_t;

static void *parent_worker_batched(void *arg) {
    parent_batch_arg_t *pa = (parent_batch_arg_t *)arg;

    // TODO: inside each parent:
    // nextChild = 1
    // while nextChild <= B_CHILDREN_PER_PARENT:
    //   - create up to child_batch_size children
    //   - join that batch
    // end while
    // parent increments destroyed
    atomic_fetch_add(&destroyed, 1);

    // TODO: free pa if allocated on heap
    return NULL;
}

static void run2b_two_level_batched(int child_batch_size) {
    printf("\n=== 2.b Two-level (BATCHED children), child_batch_size=%d ===\n", child_batch_size);
    long long start = now_ns();

    // TODO: same as run2b_two_level_no_batching, but use parent_worker_batched
    // and pass child_batch_size into each parent.

    long long end = now_ns();
    print_summary("2.b(batched)", start, end);

    // TODO: verify created == destroyed == N_TOTAL
}

// ============================================================
// 2.c — Three-level hierarchy (initial -> child -> grandchild)
// ============================================================

typedef struct {
    int initial_id;
    // TODO: include any other fields needed
} initial_arg_t;

typedef struct {
    int initial_id;
    int child_id;
    int grand_batch_size; // optional for batched grandchildren
} child_arg_t;

static void *grandchild_worker(void *arg) {
    // TODO: minimal work
    atomic_fetch_add(&destroyed, 1);
    return NULL;
}

static void *child_worker_no_batching(void *arg) {
    child_arg_t *ca = (child_arg_t *)arg;

    // TODO: create C_GRANDCHILDREN_PER_CHILD grandchildren
    // TODO: join all grandchildren
    // TODO: increment destroyed for child
    atomic_fetch_add(&destroyed, 1);

    // TODO: free ca if allocated on heap
    return NULL;
}

static void *initial_worker_no_batching(void *arg) {
    initial_arg_t *ia = (initial_arg_t *)arg;

    // TODO: create C_CHILDREN_PER_INITIAL child threads
    //   - each child creates grandchildren (no batching)
    // TODO: join all children
    // TODO: increment destroyed for initial
    atomic_fetch_add(&destroyed, 1);

    // TODO: free ia if allocated on heap
    return NULL;
}

static void run2c_three_level_no_batching(void) {
    printf("\n=== 2.c Three-level (no batching) ===\n");
    long long start = now_ns();

    // TODO: allocate pthread_t array size C_INITIALS
    // TODO: for initialId in 1..C_INITIALS:
    //   - atomic_fetch_add(&created, 1) // initial
    //   - allocate/prepare initial_arg_t
    //   - pthread_create initial thread
    // TODO: join all initials
    // TODO: free allocated memory

    long long end = now_ns();
    print_summary("2.c", start, end);

    // TODO: verify created == destroyed == N_TOTAL
}

// ============================================================
// 2.c — Three-level hierarchy (batched grandchildren, if needed)
// ============================================================

static void *child_worker_batched_grandchildren(void *arg) {
    child_arg_t *ca = (child_arg_t *)arg;

    // TODO: inside each child:
    // nextGrand = 1
    // while nextGrand <= C_GRANDCHILDREN_PER_CHILD:
    //   - create up to grand_batch_size grandchildren
    //   - join that batch
    // end while
    // increment destroyed for child
    atomic_fetch_add(&destroyed, 1);

    // TODO: free ca if allocated on heap
    return NULL;
}

static void *initial_worker_batched_grandchildren(void *arg) {
    initial_arg_t *ia = (initial_arg_t *)arg;

    // TODO: create child threads; each child uses child_worker_batched_grandchildren
    // TODO: join all children
    // TODO: increment destroyed for initial
    atomic_fetch_add(&destroyed, 1);

    // TODO: free ia if allocated on heap
    return NULL;
}

static void run2c_three_level_batched(int grand_batch_size) {
    printf("\n=== 2.c Three-level (BATCHED grandchildren), grand_batch_size=%d ===\n", grand_batch_size);
    long long start = now_ns();

    // TODO: same as run2c_three_level_no_batching, but use initial_worker_batched_grandchildren
    // and pass grand_batch_size to children via child_arg_t.

    long long end = now_ns();
    print_summary("2.c(batched)", start, end);

    // TODO: verify created == destroyed == N_TOTAL
}

// ============================================================
// main
// ============================================================
int main(void) {
    // TODO: run 3 trials each and compute averages in your report.

    reset_counts();
    run2a_flat_no_batching();
    // reset_counts();
    // run2a_flat_batched(A_BATCH_SIZE);

    reset_counts();
    run2b_two_level_no_batching();
    // reset_counts();
    // run2b_two_level_batched(B_CHILD_BATCH_SIZE);

    reset_counts();
    run2c_three_level_no_batching();
    // reset_counts();
    // run2c_three_level_batched(C_GRANDCHILD_BATCH_SIZE);

    return 0;
}
